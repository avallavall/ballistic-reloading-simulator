---
phase: 01-3-curve-burn-model
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/app/models/powder.py
  - backend/app/schemas/powder.py
  - backend/app/db/migrations/versions/004_add_3curve_columns.py
  - backend/app/core/grt_converter.py
  - backend/app/api/simulate.py
  - backend/app/api/powders.py
  - frontend/src/lib/types.ts
  - frontend/src/lib/api.ts
  - frontend/src/app/powders/page.tsx
  - backend/tests/test_schema_validation.py
  - backend/tests/test_api_integration.py
autonomous: true
requirements:
  - SIM-02

must_haves:
  truths:
    - "Powder DB model has 7 new nullable Float columns (ba, bp, br, brp, z1, z2, a0) persisted to PostgreSQL"
    - "GRT import stores 3-curve params in first-class DB columns AND passes them to grt_params JSON for reference"
    - "Simulation endpoint reads 3-curve columns from powder row and populates PowderParams with them"
    - "Powders list table shows '3C' badge for powders with 3-curve data and '2C' badge for powders without"
    - "Powder create/edit form has a collapsible 'Avanzado: Parametros 3-Curvas' section with 7 optional GRT fields"
    - "Import collision dialog offers skip/overwrite per duplicate plus batch 'Omitir todos' / 'Sobrescribir todos' buttons"
    - "Editable GRT params show a warning: 'Modificar parametros del modelo puede reducir la precision'"
    - "Existing 2-curve powders continue to work (null 3-curve columns are handled gracefully)"
  artifacts:
    - path: "backend/app/models/powder.py"
      provides: "7 new nullable Float columns for GRT 3-curve parameters"
      contains: "ba = Column(Float, nullable=True)"
    - path: "backend/app/schemas/powder.py"
      provides: "Optional 3-curve fields in PowderCreate, PowderUpdate, PowderResponse + has_3curve computed field"
      contains: "ba: float | None"
    - path: "backend/app/db/migrations/versions/004_add_3curve_columns.py"
      provides: "Alembic migration adding 7 columns to powders table"
      contains: "op.add_column"
    - path: "backend/app/core/grt_converter.py"
      provides: "Updated converter that populates first-class 3-curve fields"
      contains: "\"ba\":"
    - path: "backend/app/api/simulate.py"
      provides: "_make_params reads 3-curve columns and passes to PowderParams"
      contains: "ba=powder_row.ba"
    - path: "frontend/src/app/powders/page.tsx"
      provides: "3C/2C badge, collapsible advanced section, collision dialog"
      contains: "3C"
    - path: "frontend/src/lib/types.ts"
      provides: "3-curve fields on Powder and PowderCreate interfaces"
      contains: "ba?: number"
  key_links:
    - from: "backend/app/api/simulate.py"
      to: "backend/app/models/powder.py"
      via: "_make_params reads 3-curve DB columns"
      pattern: "ba=powder_row\\.ba"
    - from: "backend/app/core/grt_converter.py"
      to: "backend/app/schemas/powder.py"
      via: "converter output matches PowderCreate fields"
      pattern: "\"ba\":"
    - from: "frontend/src/app/powders/page.tsx"
      to: "frontend/src/lib/types.ts"
      via: "Powder interface with 3-curve fields"
      pattern: "powder\\.ba"
---

<objective>
Extend the powder data model with first-class 3-curve GRT columns, update the GRT converter to populate them natively, wire them through the simulation API, and update the frontend powders page with 3C/2C badges, a collapsible advanced parameter section, and an improved collision dialog.

Purpose: SIM-02 requires GRT-native parameters (Ba, k, z1, z2, Bp, Br, Brp) as first-class fields. Currently these are only stored in a grt_params JSON blob and ignored by the solver. This plan promotes them to proper DB columns, wires them to the solver (from Plan 01), and exposes them in the UI per user decisions.

Output: Full stack support for 3-curve powder data -- from DB storage through API to frontend display and editing.
</objective>

<execution_context>
@C:/Users/vall-/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/vall-/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-3-curve-burn-model/01-RESEARCH.md
@.planning/phases/01-3-curve-burn-model/01-01-SUMMARY.md

# Source files being modified
@backend/app/models/powder.py
@backend/app/schemas/powder.py
@backend/app/core/grt_converter.py
@backend/app/api/simulate.py
@backend/app/api/powders.py
@frontend/src/lib/types.ts
@frontend/src/lib/api.ts
@frontend/src/app/powders/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend -- DB migration, model, schema, converter, API wiring</name>
  <files>
    backend/app/models/powder.py
    backend/app/schemas/powder.py
    backend/app/db/migrations/versions/004_add_3curve_columns.py
    backend/app/core/grt_converter.py
    backend/app/api/simulate.py
    backend/app/api/powders.py
    backend/tests/test_schema_validation.py
    backend/tests/test_api_integration.py
  </files>
  <action>
**1. Powder model (backend/app/models/powder.py):**
Add 7 new nullable Float columns after the existing `grt_params` column:
```python
ba = Column(Float, nullable=True)    # GRT vivacity coefficient
bp = Column(Float, nullable=True)    # Progressivity factor
br = Column(Float, nullable=True)    # Brisance factor
brp = Column(Float, nullable=True)   # Combined factor
z1 = Column(Float, nullable=True)    # Phase 1/2 transition
z2 = Column(Float, nullable=True)    # Phase 2/3 transition
a0 = Column(Float, nullable=True)    # Ba(phi) coefficient 0
```

**2. Alembic migration (backend/app/db/migrations/versions/004_add_3curve_columns.py):**
Follow the pattern from existing migration 003. Create a new migration file:
- `revision = "004"` (check existing revision chain for correct down_revision -- should be the revision ID from 003)
- `upgrade()`: Add all 7 columns with `op.add_column("powders", sa.Column("ba", sa.Float, nullable=True))` etc.
- `downgrade()`: Drop all 7 columns.
- Read the 003 migration file first to get its exact revision ID for the `down_revision` field.

**3. Powder schemas (backend/app/schemas/powder.py):**
- `PowderCreate`: Add 7 optional fields with physical limit validation:
  ```python
  ba: float | None = Field(None, ge=0.01, le=10.0, description="GRT vivacity coefficient")
  bp: float | None = Field(None, ge=0.0, le=1.0, description="Progressivity factor")
  br: float | None = Field(None, ge=0.0, le=1.0, description="Brisance factor")
  brp: float | None = Field(None, ge=0.0, le=1.0, description="Combined Bp/Br factor")
  z1: float | None = Field(None, ge=0.01, le=0.99, description="Phase 1/2 burn-up limit")
  z2: float | None = Field(None, ge=0.02, le=0.99, description="Phase 2/3 burn-up limit")
  a0: float | None = Field(None, ge=0.0, le=20.0, description="Ba(phi) coefficient 0")
  ```
- `PowderUpdate`: Same 7 fields, all optional.
- `PowderResponse`: Same 7 fields as optional + a computed `has_3curve` boolean:
  ```python
  ba: float | None = None
  bp: float | None = None
  br: float | None = None
  brp: float | None = None
  z1: float | None = None
  z2: float | None = None
  a0: float | None = None
  has_3curve: bool = False
  ```
  Add a model validator (or use `@computed_field`) that sets `has_3curve = True` if all of ba, bp, br, brp, z1, z2 are not None.

**4. GRT converter (backend/app/core/grt_converter.py):**
Modify `convert_grt_to_powder()` to include the 3-curve fields as first-class output keys:
```python
powder_data = {
    # ... existing fields ...
    "ba": ba,                              # Direct from GRT
    "bp": bp,                              # Direct from GRT
    "br": grt_params.get("Br", None),      # Direct from GRT
    "brp": grt_params.get("Brp", None),    # Direct from GRT
    "z1": grt_params.get("z1", None),      # Direct from GRT
    "z2": grt_params.get("z2", None),      # Direct from GRT
    "a0": grt_params.get("a0", None),      # Direct from GRT
    "grt_params": _build_grt_storage(grt_params),
}
```
Note: `ba` and `bp` are already extracted as local variables in the existing code. `Br`, `Brp`, `z1`, `z2`, `a0` need to be extracted with `.get()`. Use None (not 0.0) as default so has_3curve stays False for incomplete data.

**5. Simulation API wiring (backend/app/api/simulate.py):**
In the `_make_params()` function, add 3-curve fields when constructing PowderParams:
```python
powder = PowderParams(
    force_j_kg=powder_row.force_constant_j_kg,
    covolume_m3_kg=powder_row.covolume_m3_kg,
    burn_rate_coeff=powder_row.burn_rate_coeff,
    burn_rate_exp=powder_row.burn_rate_exp,
    gamma=powder_row.gamma,
    density_kg_m3=powder_row.density_g_cm3 * GCM3_TO_KGM3,
    flame_temp_k=powder_row.flame_temp_k,
    # 3-curve fields (None if not present -> 2-curve fallback)
    ba=powder_row.ba,
    bp=powder_row.bp,
    br=powder_row.br,
    brp=powder_row.brp,
    z1=powder_row.z1,
    z2=powder_row.z2,
)
```
Also update `simulate_from_db()` in `solver.py` with the same 3-curve field mapping.

**6. Powders API (backend/app/api/powders.py):**
Check the existing import endpoint. Ensure that when a GRT file is imported, the 3-curve fields from the converter output are included in the ORM object creation. The existing code likely does `Powder(**powder_data)` which should work automatically if the converter returns the new fields and the model has the columns.

Also verify the collision handling in the import endpoint. Per user decisions, collisions should offer skip/overwrite. Check if the current code skips duplicates (it likely does based on the `GrtImportResult` schema with `skipped` field). If overwrite is not yet supported, note it for the frontend task (the backend import endpoint should accept a `collision_mode` parameter or the frontend should handle it by calling PUT for overwrites).

**7. Tests (backend/tests/test_schema_validation.py):**
Add tests for the new schema fields:
- `test_powder_create_3curve_fields_optional` -- PowderCreate without 3-curve fields is valid
- `test_powder_create_3curve_fields_valid` -- PowderCreate with all 7 GRT fields passes validation
- `test_powder_create_z1_z2_bounds` -- z1 and z2 outside [0.01, 0.99] rejected
- `test_powder_response_has_3curve_true` -- PowderResponse with all 6 core fields set has `has_3curve=True`
- `test_powder_response_has_3curve_false` -- PowderResponse with missing fields has `has_3curve=False`

**8. Tests (backend/tests/test_api_integration.py):**
Add test for 3-curve parameter persistence in simulate endpoint:
- `test_direct_simulation_with_3curve_powder` -- Create a powder with 3-curve fields via POST, verify the fields are returned. Then run a direct simulation with that powder to verify it works end-to-end.

Run: `cd backend && python -m pytest tests/ -v`
  </action>
  <verify>
- `cd backend && python -m pytest tests/ -v` -- ALL tests pass
- Check migration file exists: `ls backend/app/db/migrations/versions/004*`
- Verify schema validation: `cd backend && python -m pytest tests/test_schema_validation.py -v -k "3curve"`
  </verify>
  <done>
- Powder model has 7 new nullable columns
- Migration file creates/drops the columns
- Schemas validate 3-curve fields with physical limits
- PowderResponse includes computed has_3curve field
- GRT converter outputs first-class 3-curve fields
- Simulation API passes 3-curve fields to PowderParams
- All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Frontend -- 3C/2C badges, collapsible GRT section, collision dialog</name>
  <files>
    frontend/src/lib/types.ts
    frontend/src/lib/api.ts
    frontend/src/app/powders/page.tsx
  </files>
  <action>
**1. TypeScript types (frontend/src/lib/types.ts):**
Add 3-curve fields to the `Powder` interface:
```typescript
export interface Powder {
  // ... existing fields ...
  ba?: number | null;
  bp?: number | null;
  br?: number | null;
  brp?: number | null;
  z1?: number | null;
  z2?: number | null;
  a0?: number | null;
  has_3curve: boolean;
}
```

Add same optional fields to `PowderCreate`:
```typescript
export interface PowderCreate {
  // ... existing fields ...
  ba?: number | null;
  bp?: number | null;
  br?: number | null;
  brp?: number | null;
  z1?: number | null;
  z2?: number | null;
  a0?: number | null;
}
```

**2. Powders page (frontend/src/app/powders/page.tsx):**

**A. 3C/2C Badge in table:**
In the table row, next to the powder name, add a badge:
```tsx
<TableCell className="font-medium text-white">
  <span className="flex items-center gap-2">
    {powder.name}
    <Badge variant={powder.has_3curve ? 'success' : 'default'}>
      {powder.has_3curve ? '3C' : '2C'}
    </Badge>
  </span>
</TableCell>
```
Use `variant="success"` (green) for 3C and `variant="default"` (gray) for 2C.

**B. Collapsible "Avanzado: Parametros 3-Curvas" section in create/edit form:**
After the existing form fields grid, add a collapsible section using a simple `<details>` element or a state toggle:
```tsx
const [showAdvanced, setShowAdvanced] = useState(false);
```

Add a button/toggle below the existing fields:
```tsx
<button
  type="button"
  onClick={() => setShowAdvanced(!showAdvanced)}
  className="flex items-center gap-1 text-sm text-slate-400 hover:text-slate-300"
>
  {showAdvanced ? '▼' : '▶'} Avanzado: Parametros 3-Curvas
</button>
```

When expanded, show a grid with 7 optional fields (Ba, Bp, Br, Brp, z1, z2, a0). Each uses `<Input>` with type="number", step="any".

Add a yellow warning banner inside the collapsible section (per user decision):
```tsx
<div className="rounded-md bg-yellow-500/10 border border-yellow-500/30 px-3 py-2 text-xs text-yellow-300">
  ⚠ Modificar parametros del modelo puede reducir la precision
</div>
```

Update `emptyForm` to include the 3-curve fields as `undefined` (or `null`). Update `handleChange` to handle these fields. Update `handleEdit` to populate them from the existing powder.

**C. Collision dialog for import:**
Per user decisions: "On name collisions: show a dialog asking the user to skip or overwrite for each duplicate."
Per research pitfall 5: "Offer batch actions: 'Skip All Duplicates' and 'Overwrite All Duplicates' buttons."

Modify the import flow:
1. The backend import endpoint currently returns `skipped` names. Change the flow to a two-step process:
   - First, send the file to a "preview" or use the existing import endpoint.
   - If there are collisions (skipped names), show a modal listing the duplicates with options: per-powder checkboxes to select overwrite, plus "Omitir todos" and "Sobrescribir todos" buttons.
   - On "Sobrescribir todos" or individual selections, call the import endpoint again with `overwrite=true` parameter (or call individual PUT endpoints for each overwrite).

   **Simpler alternative (preferred to keep scope manageable):** Modify the import flow to show the collision list in the summary modal with two buttons: "Omitir duplicados" (do nothing, keep existing) and "Sobrescribir duplicados" (re-import with overwrite flag). The backend import endpoint needs a query parameter `?overwrite=true` that updates existing powders instead of skipping them. This matches the user's "skip or overwrite for each duplicate" decision while being batch-oriented per the pitfall guidance.

   Update the backend `POST /api/v1/powders/import` endpoint (in `powders.py`) to accept an `overwrite: bool = False` query parameter. When True and a powder name already exists, update it instead of skipping.

   Update the frontend import result display to show overwrite button when there are skipped powders.

Run: `cd frontend && npm run build` (should compile without errors)
  </action>
  <verify>
- `cd frontend && npx tsc --noEmit` -- no TypeScript errors
- Manual check: Powders page renders with 3C/2C badges
- Manual check: Create/edit form shows collapsible advanced section
  </verify>
  <done>
- Powder and PowderCreate types include 3-curve fields
- Powders table shows 3C/2C badge next to each powder name
- Create/edit form has collapsible "Avanzado: Parametros 3-Curvas" section with 7 fields and warning message
- Import collision dialog shows skip/overwrite options for duplicates
- Frontend compiles without errors
  </done>
</task>

</tasks>

<verification>
1. Backend tests pass: `cd backend && python -m pytest tests/ -v` -- 0 failures
2. Frontend compiles: `cd frontend && npx tsc --noEmit` -- 0 errors
3. Migration file is valid: `ls backend/app/db/migrations/versions/004*`
4. GRT converter outputs first-class fields: check converter unit test or grep for "ba" in converter output
5. Simulation with 3-curve powder works end-to-end: `test_direct_simulation_with_3curve_powder` passes
6. PowderResponse.has_3curve computed correctly: schema tests pass
</verification>

<success_criteria>
- 7 new nullable columns in powder model + migration
- Schemas validate 3-curve params with physical bounds
- GRT converter populates first-class columns (not just JSON blob)
- Simulation API reads 3-curve columns and passes to PowderParams
- Frontend shows 3C/2C badges on powders table
- Collapsible advanced section with warning in create/edit form
- Import collision handling with overwrite option
- All backend tests pass, frontend compiles
</success_criteria>

<output>
After completion, create `.planning/phases/01-3-curve-burn-model/01-02-SUMMARY.md`
</output>
