---
phase: 01-3-curve-burn-model
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - backend/app/core/thermodynamics.py
  - backend/app/core/solver.py
  - backend/tests/test_thermodynamics.py
  - backend/tests/test_solver.py
autonomous: true
requirements:
  - SIM-01

must_haves:
  truths:
    - "form_function_3curve(z, z1, z2, bp, br, brp) returns monotonically increasing values from 0 to 1 for z in [0, 1]"
    - "form_function_3curve is C0-continuous at z1 and z2 transition points (no jumps)"
    - "PowderParams with 3-curve fields (ba, bp, br, brp, z1, z2) triggers 3-curve solver path"
    - "PowderParams without 3-curve fields (all None) uses existing 2-curve path identically"
    - "Existing .308 Win simulation produces bit-identical results after changes (golden output test)"
    - "3-curve simulation produces a realistic pressure curve with no artifacts at transition points"
  artifacts:
    - path: "backend/app/core/thermodynamics.py"
      provides: "form_function_3curve() piecewise polynomial function"
      contains: "def form_function_3curve"
    - path: "backend/app/core/solver.py"
      provides: "Dual-mode PowderParams with has_3curve property, modified ODE system"
      contains: "has_3curve"
    - path: "backend/tests/test_thermodynamics.py"
      provides: "Tests for 3-curve form function: monotonicity, continuity, edge cases"
      contains: "test_form_function_3curve"
    - path: "backend/tests/test_solver.py"
      provides: "Golden output test for 2-curve backward compat + 3-curve simulation test"
      contains: "test_golden_output_2curve"
  key_links:
    - from: "backend/app/core/solver.py"
      to: "backend/app/core/thermodynamics.py"
      via: "import form_function_3curve"
      pattern: "from app\\.core\\.thermodynamics import.*form_function_3curve"
    - from: "backend/app/core/solver.py"
      to: "PowderParams.has_3curve"
      via: "conditional form function dispatch in _build_ode_system"
      pattern: "if powder\\.has_3curve"
---

<objective>
Implement the 3-curve piecewise form function for propellant combustion and integrate it into the ODE solver with automatic 2-curve/3-curve dispatch.

Purpose: This is the physics engine foundation for Phase 1. The 3-curve model divides combustion into three phases (initial/main/tail-off) using z1/z2 transitions, producing more accurate pressure curves than the current 2-curve approximation.

Output: Working dual-mode solver that uses 3-curve math when GRT parameters are available and falls back to existing 2-curve behavior when they are not, verified by TDD.
</objective>

<execution_context>
@C:/Users/vall-/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/vall-/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-3-curve-burn-model/01-RESEARCH.md

# Source files being modified
@backend/app/core/thermodynamics.py
@backend/app/core/solver.py
@backend/tests/test_thermodynamics.py
@backend/tests/test_solver.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED -- Write failing tests for 3-curve form function and dual-mode solver</name>
  <files>backend/tests/test_thermodynamics.py, backend/tests/test_solver.py</files>
  <action>
**In test_thermodynamics.py**, add these test functions (import `form_function_3curve` from `app.core.thermodynamics` -- it does not exist yet, so tests will fail):

1. `test_form_function_3curve_boundary_values` -- Test that:
   - `form_function_3curve(0, 0.4, 0.8, 0.15, 0.10, 0.12)` returns 0.0
   - `form_function_3curve(1.0, 0.4, 0.8, 0.15, 0.10, 0.12)` returns 1.0

2. `test_form_function_3curve_monotonic` -- Test that for z values [0, 0.1, 0.2, ..., 1.0] with realistic params (z1=0.4, z2=0.8, bp=0.15, br=0.10, brp=0.12), each successive value is >= the previous. Use `assert all(vals[i+1] >= vals[i] for i in range(len(vals)-1))`.

3. `test_form_function_3curve_continuity_at_z1` -- Test that the function is continuous at z1: `abs(f(z1 - 1e-10) - f(z1 + 1e-10)) < 1e-6` for z1=0.4, z2=0.8, bp=0.15, br=0.10, brp=0.12.

4. `test_form_function_3curve_continuity_at_z2` -- Same as above but at z2.

5. `test_form_function_3curve_clamping` -- Test that negative z returns 0.0 and z > 1.0 returns 1.0.

6. `test_form_function_3curve_multiple_powders` -- Parametrize with real GRT data from research:
   - Hodgdon 50BMG: Bp=0.0936, Br=0.0794, Brp=0.0868, z1=0.4804, z2=0.8363
   - Hodgdon H380 #3: Bp=0.1717, Br=0.1259, Brp=0.1506, z1=0.3391, z2=0.4215
   - Alliant RL 25: Bp=0.1238, Br=0.0892, Brp=0.1079, z1=0.6264, z2=0.6890
   - Win StaBALL Match: Bp=0.1995, Br=0.1310, Brp=0.1688, z1=0.4296, z2=0.8867
   For each: verify psi(0)=0, psi(1)=1, monotonic, continuous at z1/z2.

7. `test_form_function_3curve_midpoint_progressive` -- For a progressive powder (Bp > 0, Br > 0), verify that psi(0.5) is between 0.3 and 0.7 (reasonable range for progressive powders).

**In test_solver.py**, add:

8. `test_golden_output_2curve` -- Run the existing `make_308_params()` simulation (using the current parameters), capture the exact `peak_pressure_psi` and `muzzle_velocity_fps` values. Hard-code them with a tolerance of 0.1% (relative). This is the backward compatibility guard. **IMPORTANT**: First run the simulation to get the actual current values, then hard-code those exact values into the test.

9. `test_3curve_simulation_runs` -- Create PowderParams with 3-curve fields populated (ba=0.496, bp=0.1717, br=0.1259, brp=0.1506, z1=0.3391, z2=0.4215) plus the standard 2-curve fields. Verify: simulation completes without error, peak_pressure_psi > 0, muzzle_velocity_fps > 0, pressure_curve is non-empty, no "Integration failed" in warnings.

10. `test_3curve_has_3curve_property` -- Verify `PowderParams(..., ba=0.5, bp=0.1, br=0.1, brp=0.1, z1=0.4, z2=0.8).has_3curve` is True, and `PowderParams(...).has_3curve` (without 3-curve fields) is False.

Run tests: `cd backend && python -m pytest tests/test_thermodynamics.py tests/test_solver.py -v`. All new tests should FAIL (ImportError or AttributeError). Existing tests should still pass.
  </action>
  <verify>`cd backend && python -m pytest tests/test_thermodynamics.py tests/test_solver.py -v 2>&1 | grep -E "(PASSED|FAILED|ERROR)"` -- new tests fail, existing tests pass.</verify>
  <done>All new test functions exist and fail for the right reasons (missing function/attribute). All pre-existing tests still pass.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN -- Implement 3-curve form function and dual-mode solver</name>
  <files>backend/app/core/thermodynamics.py, backend/app/core/solver.py</files>
  <action>
**In thermodynamics.py**, add (DO NOT modify the existing `form_function`):

```python
def form_function_3curve(z: float, z1: float, z2: float,
                         bp: float, br: float, brp: float) -> float:
    """Three-phase piecewise form function for GRT-style 3-curve burn model.

    Divides combustion into three phases:
      Phase 1 (0 <= z < z1): Initial ignition. psi_raw = z + bp * z^2
      Phase 2 (z1 <= z < z2): Main combustion. psi_raw = psi(z1) + (z-z1) + brp*(z-z1)*(z+z1)
      Phase 3 (z2 <= z <= 1): Tail-off. psi_raw = psi(z2) + (z-z2) + br*(z-z2)*(z+z2)

    Normalized so psi(1.0) = 1.0.

    Args:
        z: Normalized burn depth (0 to 1).
        z1: Phase 1/2 transition point.
        z2: Phase 2/3 transition point.
        bp: Progressivity factor.
        br: Brisance factor.
        brp: Combined progressivity/brisance factor.

    Returns:
        Fraction burned psi (0 to 1).
    """
    z_c = float(np.clip(z, 0.0, 1.0))

    # Phase 1: 0 to z1
    psi_z1 = z1 + bp * z1 ** 2

    if z_c <= z1:
        psi_raw = z_c + bp * z_c ** 2
    elif z_c <= z2:
        # Phase 2: z1 to z2 (transition using brp)
        dz = z_c - z1
        psi_raw = psi_z1 + dz + brp * dz * (z_c + z1)
    else:
        # Phase 3: z2 to 1.0 (tail-off using br)
        dz12 = z2 - z1
        psi_z2 = psi_z1 + dz12 + brp * dz12 * (z2 + z1)
        dz = z_c - z2
        psi_raw = psi_z2 + dz + br * dz * (z_c + z2)

    # Normalize so psi(1.0) = 1.0
    # Compute psi_raw at z=1.0
    dz12 = z2 - z1
    psi_z2_total = psi_z1 + dz12 + brp * dz12 * (z2 + z1)
    dz_tail = 1.0 - z2
    psi_total = psi_z2_total + dz_tail + br * dz_tail * (1.0 + z2)

    if psi_total <= 0.0:
        return 0.0

    return float(np.clip(psi_raw / psi_total, 0.0, 1.0))
```

**In solver.py**, make these changes:

1. Add import at the top: `from app.core.thermodynamics import form_function, form_function_3curve, noble_abel_pressure, vieille_burn_rate`

2. Extend `PowderParams` dataclass with optional 3-curve fields:
```python
    # 3-curve GRT parameters (optional -- None = use 2-curve Vieille)
    ba: float | None = None
    bp: float | None = None
    br: float | None = None
    brp: float | None = None
    z1: float | None = None
    z2: float | None = None

    @property
    def has_3curve(self) -> bool:
        """Check if all 3-curve parameters are available."""
        return all(v is not None for v in [self.ba, self.bp, self.br, self.brp, self.z1, self.z2])
```

3. In `_build_ode_system`, modify the `rhs` function:
- Extract 3-curve params once before the inner function: `use_3curve = powder.has_3curve`
- If `use_3curve`, also extract `ba_val, bp_val, br_val, brp_val, z1_val, z2_val = powder.ba, powder.bp, powder.br, powder.brp, powder.z1, powder.z2`
- In the `rhs()` inner function, change the psi calculation:
  ```python
  if use_3curve:
      psi = form_function_3curve(Z_c, z1_val, z2_val, bp_val, br_val, brp_val)
  else:
      psi = form_function(Z_c, theta)
  ```
- The burn rate (dZ_dt) calculation remains Vieille-based for BOTH modes. The 3-curve model only changes the form function (psi), not the burn rate law. This is the simpler approach from the research -- start with 3-curve form function + existing Vieille burn rate. Direct Ba-based burn rate is a future iteration if accuracy is insufficient.

4. In the `simulate()` function, in the post-processing loop where pressure/velocity curves are computed, apply the same conditional psi:
```python
if powder.has_3curve:
    psi = form_function_3curve(Z_c, powder.z1, powder.z2, powder.bp, powder.br, powder.brp)
else:
    psi = form_function(Z_c, powder.theta)
```

**Critical constraint:** The behavior for powders WITHOUT 3-curve fields must be IDENTICAL to current behavior. No changes to the existing form_function(), no changes to default parameter values. The `has_3curve` property gates ALL new behavior.

Run all tests: `cd backend && python -m pytest tests/ -v`
  </action>
  <verify>`cd backend && python -m pytest tests/ -v` -- ALL tests pass (both new and existing). Specifically verify: `test_golden_output_2curve` passes (backward compat), `test_3curve_simulation_runs` passes, all `test_form_function_3curve_*` pass.</verify>
  <done>3-curve form function implemented and passes all tests. Existing 2-curve simulations produce identical results (golden output test confirms). 3-curve simulation produces realistic results.</done>
</task>

</tasks>

<verification>
1. Run full backend test suite: `cd backend && python -m pytest tests/ -v` -- ALL tests pass
2. Verify backward compatibility: `test_golden_output_2curve` passes with 0.1% tolerance
3. Verify 3-curve math: `test_form_function_3curve_monotonic` and `test_form_function_3curve_continuity_*` pass
4. Verify dual-mode: `test_3curve_has_3curve_property` passes
5. Verify 3-curve simulation: `test_3curve_simulation_runs` produces non-zero results with no integration failures
</verification>

<success_criteria>
- form_function_3curve is implemented with piecewise polynomial, normalized to [0,1]
- PowderParams has optional ba/bp/br/brp/z1/z2 fields and has_3curve property
- Solver dispatches between 2-curve and 3-curve based on has_3curve
- All existing tests pass unchanged (backward compatibility)
- All new tests pass (8+ new tests for 3-curve)
- Full test suite: 0 failures
</success_criteria>

<output>
After completion, create `.planning/phases/01-3-curve-burn-model/01-01-SUMMARY.md`
</output>
