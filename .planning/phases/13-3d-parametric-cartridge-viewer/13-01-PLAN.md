---
phase: 13-3d-parametric-cartridge-viewer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/lib/geometry/mesh-builder.ts
  - frontend/src/lib/geometry/materials.ts
  - frontend/public/hdri/studio_small.hdr
autonomous: true
requirements: [VIS3-01]

must_haves:
  truths:
    - "profileToLatheGeometry converts ProfilePoint[] to Three.js LatheGeometry with correct axis mapping (y->radial, x->axial)"
    - "PBR material definitions exist for brass, copper, lead, nickel, and powder with realistic metalness/roughness values"
    - "getBulletMaterials returns correct jacket+core materials based on bullet_type (FMJ, HP, solid copper)"
    - "HDR environment map file exists at public/hdri/studio_small.hdr for metallic reflections"
  artifacts:
    - path: "frontend/src/lib/geometry/mesh-builder.ts"
      provides: "ProfilePoint[] to LatheGeometry conversion functions"
      exports: ["profileToLatheGeometry", "profileToHalfLatheGeometry", "createPrimerGeometry", "createPowderFillGeometry"]
    - path: "frontend/src/lib/geometry/materials.ts"
      provides: "PBR material parameter definitions for all cartridge components"
      exports: ["MATERIALS", "getBulletMaterials"]
    - path: "frontend/public/hdri/studio_small.hdr"
      provides: "HDR environment map for realistic metallic reflections"
  key_links:
    - from: "frontend/src/lib/geometry/mesh-builder.ts"
      to: "frontend/src/lib/geometry/types.ts"
      via: "imports ProfilePoint type"
      pattern: "import.*ProfilePoint.*from.*types"
---

<objective>
Create pure geometry-to-mesh conversion library and PBR material definitions for 3D cartridge rendering.

Purpose: Establish the foundational pure computation layer (zero React imports) that converts existing `ProfilePoint[]` arrays from the geometry engine into Three.js `LatheGeometry` objects, plus realistic PBR material parameters. This follows the project's established pattern of pure computation libraries consumed by React components.

Output: `mesh-builder.ts` with LatheGeometry converters, `materials.ts` with PBR material configs, and a local HDR environment map file.
</objective>

<execution_context>
@C:/Users/vall-/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/vall-/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-3d-parametric-cartridge-viewer/13-CONTEXT.md
@.planning/phases/13-3d-parametric-cartridge-viewer/13-RESEARCH.md
@frontend/src/lib/geometry/types.ts

<interfaces>
<!-- Key types from existing geometry engine that mesh-builder.ts will consume -->

From frontend/src/lib/geometry/types.ts:
```typescript
export interface ProfilePoint {
  x: number;  // mm, axial position (0 = case head / bullet base)
  y: number;  // mm, radial position (half-diameter from centerline)
}

export interface GeometryResult {
  svgPath: string;
  profilePoints: ProfilePoint[];
  estimatedFields: string[];
  dataCompleteness: 'full' | 'basic' | 'insufficient';
}
```

Three.js LatheGeometry constructor (from docs):
```typescript
new THREE.LatheGeometry(
  points: Vector2[],   // x = radial distance (>0), y = axial position
  segments?: number,   // default 12, use 64 for smooth revolution
  phiStart?: number,   // default 0
  phiLength?: number   // default 2*PI, use PI for half-revolution
)
```

CRITICAL axis mapping: ProfilePoint.x (axial) -> Vector2.y, ProfilePoint.y (radial) -> Vector2.x
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mesh-builder.ts and materials.ts pure computation libraries</name>
  <files>frontend/src/lib/geometry/mesh-builder.ts, frontend/src/lib/geometry/materials.ts</files>
  <action>
Create two pure TypeScript files with ZERO React imports (following project convention for geometry/ files).

**mesh-builder.ts:**

Import `ProfilePoint` from `./types` and `* as THREE` from `three`.

Implement these exported functions:

1. `profileToLatheGeometry(points: ProfilePoint[], segments?: number): THREE.LatheGeometry`
   - Default segments = 64 for smooth revolution
   - Map each ProfilePoint to `new THREE.Vector2(point.y, point.x)` — CRITICAL: y (radial) becomes Three.js x, x (axial) becomes Three.js y
   - Return `new THREE.LatheGeometry(vectors, segments)`

2. `profileToHalfLatheGeometry(points: ProfilePoint[], segments?: number): THREE.LatheGeometry`
   - Same as above but with `phiLength = Math.PI` (180-degree revolution for cutaway view)
   - Default segments = 32 (half the full revolution count)

3. `createPrimerGeometry(primerDiameter: number, primerHeight: number): THREE.CylinderGeometry`
   - Return `new THREE.CylinderGeometry(primerDiameter / 2, primerDiameter / 2, primerHeight, 32)`
   - Primer is a simple cylinder at the case head

4. `createPowderFillGeometry(caseInnerRadius: number, fillHeight: number): THREE.CylinderGeometry`
   - Return `new THREE.CylinderGeometry(caseInnerRadius, caseInnerRadius, fillHeight, 32)`
   - Represents the powder charge level inside the case
   - Only used when load data is available

**materials.ts:**

Define PBR material parameter objects (NOT Three.js material instances — those must be created in React components):

```typescript
export interface MaterialParams {
  color: string;
  metalness: number;
  roughness: number;
}

export const MATERIALS: Record<string, MaterialParams> = {
  brass:  { color: '#B5A642', metalness: 0.85, roughness: 0.25 },
  copper: { color: '#B87333', metalness: 0.80, roughness: 0.30 },
  lead:   { color: '#4A4A4A', metalness: 0.30, roughness: 0.70 },
  nickel: { color: '#C0C0C0', metalness: 0.90, roughness: 0.15 },
  powder: { color: '#2D2D2D', metalness: 0.00, roughness: 0.95 },
};
```

Export `getBulletMaterials(bulletType: string | null): { jacket: MaterialParams; core: MaterialParams }`:
- If bulletType is null or unrecognized: return `{ jacket: MATERIALS.copper, core: MATERIALS.lead }`
- If bulletType contains "solid" AND "copper": return `{ jacket: MATERIALS.copper, core: MATERIALS.copper }`
- If bulletType contains "hp" or "hollow": return `{ jacket: MATERIALS.copper, core: MATERIALS.lead }` (jacket visible, core exposed at tip)
- Default (FMJ): return `{ jacket: MATERIALS.copper, core: MATERIALS.lead }`

Export `CUTAWAY_COLORS: Record<string, string>`:
```typescript
export const CUTAWAY_COLORS = {
  brassWall: '#C4A44A',   // Slightly brighter brass for cross-section face
  powderSpace: '#3D3D3D', // Dark gray for powder cavity
  bulletCore: '#5A5A5A',  // Visible lead core in cutaway
  bulletJacket: '#C08040', // Copper jacket cross-section
};
```

IMPORTANT: Both files must have ZERO React imports. They are pure data/geometry producers.
  </action>
  <verify>
    <automated>cd frontend && npx tsc --noEmit src/lib/geometry/mesh-builder.ts src/lib/geometry/materials.ts 2>&1 | head -20</automated>
  </verify>
  <done>mesh-builder.ts exports 4 geometry functions, materials.ts exports MATERIALS, getBulletMaterials, and CUTAWAY_COLORS. Both files compile with zero errors. Neither file imports React.</done>
</task>

<task type="auto">
  <name>Task 2: Download HDR environment map to public/hdri/</name>
  <files>frontend/public/hdri/studio_small.hdr</files>
  <action>
Download a studio-style HDR environment map for realistic metallic reflections on the 3D model.

1. Create the directory: `mkdir -p frontend/public/hdri`
2. Download a 1K studio HDR from Poly Haven (CC0 license, free to use):
   ```bash
   curl -L "https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_09_1k.hdr" -o frontend/public/hdri/studio_small.hdr
   ```
   If that URL fails, try an alternative studio HDRI:
   ```bash
   curl -L "https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_03_1k.hdr" -o frontend/public/hdri/studio_small.hdr
   ```
   If Poly Haven is unreachable, create a minimal placeholder and add a comment noting the HDR needs manual download. The file MUST exist at `frontend/public/hdri/studio_small.hdr` for the 3D viewer to function.

3. Verify the downloaded file is a valid HDR (should be ~200-800KB). If significantly smaller (< 10KB), the download likely failed.

NOTE: drei's `<Environment>` component needs a local HDR file, NOT a CDN preset (per research: presets rely on polyhaven.com CDN which is unreliable in production). The `files` prop will reference `/hdri/studio_small.hdr` (Next.js serves from public/).
  </action>
  <verify>
    <automated>ls -la frontend/public/hdri/studio_small.hdr && wc -c < frontend/public/hdri/studio_small.hdr</automated>
  </verify>
  <done>HDR file exists at frontend/public/hdri/studio_small.hdr and is at least 100KB (valid HDR file, not an error page).</done>
</task>

</tasks>

<verification>
1. `cd frontend && npx tsc --noEmit` — zero TypeScript errors across the project
2. `ls frontend/public/hdri/studio_small.hdr` — HDR file exists
3. `grep -c "import React" frontend/src/lib/geometry/mesh-builder.ts frontend/src/lib/geometry/materials.ts` — both return 0 (pure files, no React)
4. `grep "export function" frontend/src/lib/geometry/mesh-builder.ts` — shows 4 exported functions
5. `grep "export" frontend/src/lib/geometry/materials.ts` — shows MATERIALS, getBulletMaterials, CUTAWAY_COLORS exports
</verification>

<success_criteria>
- mesh-builder.ts converts ProfilePoint[] to Three.js LatheGeometry with correct axis swap (y->x, x->y)
- materials.ts defines PBR params for brass, copper, lead, nickel, powder
- getBulletMaterials returns jacket+core pair based on bullet_type
- HDR file downloaded and available at /hdri/studio_small.hdr
- All files compile with zero errors
- No React imports in geometry/ files (pure computation pattern maintained)
</success_criteria>

<output>
After completion, create `.planning/phases/13-3d-parametric-cartridge-viewer/13-01-SUMMARY.md`
</output>
