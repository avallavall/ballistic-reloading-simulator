---
phase: 02-extended-simulation-charts
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/core/solver.py
  - backend/app/schemas/simulation.py
  - backend/app/api/simulate.py
  - backend/tests/test_solver.py
autonomous: true
requirements:
  - CHART-01
  - CHART-02
  - CHART-03
  - CHART-04

must_haves:
  truths:
    - "Simulation API response includes burn_curve, energy_curve, temperature_curve, and recoil_curve arrays alongside existing pressure_curve and velocity_curve"
    - "Sensitivity endpoint accepts center params + charge delta and returns center/upper/lower simulation results in a single response"
    - "Existing simulation behavior is unchanged -- pressure_curve, velocity_curve, and all scalar fields return identical values"
  artifacts:
    - path: "backend/app/core/solver.py"
      provides: "Extended SimResult with 4 new curve arrays"
      contains: "burn_curve"
    - path: "backend/app/schemas/simulation.py"
      provides: "SensitivityRequest and SensitivityResponse schemas"
      contains: "SensitivityRequest"
    - path: "backend/app/api/simulate.py"
      provides: "POST /simulate/sensitivity endpoint"
      contains: "sensitivity"
    - path: "backend/tests/test_solver.py"
      provides: "Tests verifying new curve arrays are populated"
      contains: "burn_curve"
  key_links:
    - from: "backend/app/core/solver.py"
      to: "backend/app/schemas/simulation.py"
      via: "SimResult fields mapped to DirectSimulationResponse"
      pattern: "burn_curve|energy_curve|temperature_curve|recoil_curve"
    - from: "backend/app/api/simulate.py"
      to: "backend/app/core/solver.py"
      via: "simulate() call for sensitivity endpoint"
      pattern: "simulate.*sensitivity"
---

<objective>
Extend the backend solver to return burn progress, energy/momentum, temperature/heat, and recoil curves from the existing ODE solution arrays, and add a /simulate/sensitivity endpoint that runs 3 simulations (center, +delta, -delta) for error band visualization.

Purpose: The solver already computes Z, v, Q_loss, and gas temperature at 200 time points, but only returns pressure_curve and velocity_curve. This plan extracts the additional physics data and exposes it via the API, providing the data layer for all new frontend charts.

Output: Extended SimResult/API response with 4 new curve arrays + sensitivity endpoint
</objective>

<execution_context>
@C:/Users/vall-/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/vall-/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-extended-simulation-charts/02-RESEARCH.md

@backend/app/core/solver.py
@backend/app/schemas/simulation.py
@backend/app/api/simulate.py
@backend/tests/test_solver.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend solver SimResult with burn, energy, temperature, and recoil curves</name>
  <files>
    backend/app/core/solver.py
    backend/app/schemas/simulation.py
    backend/tests/test_solver.py
  </files>
  <action>
**In solver.py**, inside the `simulate()` function, after the existing post-processing loop (lines 304-338) that builds `pressure_curve` and `velocity_curve`, add 4 new curve arrays by extracting data from existing ODE solution arrays (Z_arr, v_arr, Q_arr, x_arr, t_eval). All values are already computed -- no new physics needed.

1. **Compute dZ/dt array** using `np.gradient(Z_arr, t_eval)` before the loop.

2. **Inside the existing for loop** (iterating i over n_points), after the existing pressure_curve/velocity_curve appends, add:

   - `burn_curve` entry: `{"t_ms": float(t_eval[i]*1000), "z": float(Z_c), "dz_dt": float(dZ_dt_arr[i]), "psi": float(psi)}`

   - `energy_curve` entry: Compute `ke_j = 0.5 * m * v_arr[i]**2` (where m = bullet mass in kg, already available as `m`), `ke_ft_lbs = ke_j * MPS_TO_FPS / MPS_TO_FPS` -- actually use proper conversion: 1 J = 0.737562 ft-lbs. Add constant `J_TO_FT_LBS = 0.737562` at top of file. Compute `momentum_ns = m * v_arr[i]`. Entry: `{"t_ms": float(t_eval[i]*1000), "x_mm": float(x_arr[i] / MM_TO_M), "ke_j": float(ke_j), "ke_ft_lbs": float(ke_j * J_TO_FT_LBS), "momentum_ns": float(momentum_ns)}`

   - `temperature_curve` entry: Compute T_gas from Noble-Abel EOS. The gas temperature is `T_gas = P_avg * V_corrected / (n_gas * R)` where `V_corrected = V_f - omega*psi*covolume`, `n_gas = omega*psi / molecular_weight`. Simpler: use `T_gas = powder.flame_temp_k * (effective_energy / (powder.force_j_kg * omega * psi))` when psi > 0, else `T_gas = 300.0` (ambient). This accounts for heat loss reducing temperature. Entry: `{"t_ms": float(t_eval[i]*1000), "t_gas_k": float(T_gas), "q_loss_j": float(Q_arr[i])}`

   - `recoil_curve` entry: Compute recoil impulse as `impulse_ns = m * v_arr[i] + omega * psi * 1.75 * v_arr[i]` (bullet momentum + gas jet momentum using Thornhill factor 1.75). Entry: `{"t_ms": float(t_eval[i]*1000), "impulse_ns": float(impulse_ns)}`

3. **Add new fields to SimResult dataclass**: `burn_curve: list`, `energy_curve: list`, `temperature_curve: list`, `recoil_curve: list`. Initialize to `[]` in the early-return error path.

4. **Return** the new arrays in the SimResult constructor at the end of simulate().

**In simulation.py schemas**, add the 4 new curve fields to `DirectSimulationResponse` and `SimulationResultResponse`:
```python
burn_curve: list[dict] = []
energy_curve: list[dict] = []
temperature_curve: list[dict] = []
recoil_curve: list[dict] = []
```

**In test_solver.py**, add a test that runs the standard .308 Win simulation and asserts:
- `len(result.burn_curve) == 200`
- `result.burn_curve[0]["z"]` is close to Z_PRIMER (0.01)
- `result.burn_curve[-1]["z"]` is close to 1.0 (fully burned)
- `len(result.energy_curve) == 200`
- `result.energy_curve[-1]["ke_j"] > 0` (positive kinetic energy at muzzle)
- `result.energy_curve[-1]["ke_ft_lbs"] > 0`
- `len(result.temperature_curve) == 200`
- `result.temperature_curve[0]["t_gas_k"] > 300` (above ambient)
- `len(result.recoil_curve) == 200`
- `result.recoil_curve[-1]["impulse_ns"] > 0`

Also verify backward compatibility: existing golden output test values for peak_pressure and muzzle_velocity remain unchanged.
  </action>
  <verify>
Run `cd C:/Users/vall-/Desktop/projectes/simulador_balistica/backend && python -m pytest tests/test_solver.py -v` -- all existing tests pass plus new curve tests pass. Verify that golden output test (peak_pressure ~96880 psi, muzzle_velocity ~3258 fps) still passes with 0.1% tolerance.
  </verify>
  <done>
SimResult contains burn_curve, energy_curve, temperature_curve, recoil_curve arrays (each 200 points). DirectSimulationResponse schema includes the new fields. All solver tests pass including backward compat golden output.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add /simulate/sensitivity endpoint for error band data</name>
  <files>
    backend/app/schemas/simulation.py
    backend/app/api/simulate.py
    backend/tests/test_api_integration.py
  </files>
  <action>
**In simulation.py**, add new schemas:

```python
class SensitivityRequest(BaseModel):
    powder_id: uuid.UUID
    bullet_id: uuid.UUID
    rifle_id: uuid.UUID
    powder_charge_grains: float = Field(gt=0, le=200, description="Center charge weight (grains)")
    coal_mm: float = Field(gt=0, le=200, description="Cartridge overall length (mm)")
    seating_depth_mm: float = Field(gt=0, le=50, description="Bullet seating depth (mm)")
    charge_delta_grains: float = Field(default=0.3, gt=0, le=5.0, description="Charge variation +/- (grains)")

class SensitivityResponse(BaseModel):
    center: DirectSimulationResponse
    upper: DirectSimulationResponse
    lower: DirectSimulationResponse
    charge_center_grains: float
    charge_upper_grains: float
    charge_lower_grains: float
```

**In simulate.py**, add a new endpoint:

```python
@router.post("/sensitivity", response_model=SensitivityResponse)
@limiter.limit("10/minute")
async def run_sensitivity(request: Request, req: SensitivityRequest, db: AsyncSession = Depends(get_db)):
```

Implementation:
1. Load powder, bullet, rifle, cartridge from DB (reuse `_load_simulation_data` pattern or extract a shared helper from the existing `run_direct_simulation` function).
2. Build params with `_make_params()` for center charge.
3. Run `simulate()` 3 times: center, center+delta, center-delta. Use `max(0.1, center - delta)` to ensure lower charge is always positive.
4. Convert each SimResult to DirectSimulationResponse (reuse the existing conversion logic from `run_direct_simulation`).
5. Return SensitivityResponse with all 3 results plus the actual charge values used.

Rate limit at 10/minute (same as direct sim, since each call = 3 simulations internally but from user perspective it is one interaction).

**In test_api_integration.py**, add a test for the sensitivity endpoint:
- POST to `/api/v1/simulate/sensitivity` with valid component IDs and charge_delta_grains=0.5
- Assert 200 response
- Assert response has center, upper, lower keys
- Assert `response["charge_upper_grains"] == charge + 0.5`
- Assert `response["charge_lower_grains"] == charge - 0.5`
- Assert all 3 have pressure_curve with 200 points
- Assert upper.peak_pressure_psi >= center.peak_pressure_psi (more charge = more pressure)
  </action>
  <verify>
Run `cd C:/Users/vall-/Desktop/projectes/simulador_balistica/backend && python -m pytest tests/test_api_integration.py -v -k sensitivity` -- new sensitivity test passes. Also run full test suite to confirm no regressions: `python -m pytest tests/ -v`.
  </verify>
  <done>
POST /api/v1/simulate/sensitivity endpoint accepts center params + charge_delta_grains, returns center/upper/lower DirectSimulationResponse (each with all curve arrays). Rate limited at 10/minute. Integration test passes.
  </done>
</task>

</tasks>

<verification>
1. `cd backend && python -m pytest tests/ -v` -- all tests pass (existing + new)
2. Manual curl test: `curl -X POST http://localhost:8000/api/v1/simulate/direct -H "Content-Type: application/json" -d '{"powder_id":"...","bullet_id":"...","rifle_id":"...","powder_charge_grains":43.0,"coal_mm":71.0,"seating_depth_mm":5.0}'` -- response includes burn_curve, energy_curve, temperature_curve, recoil_curve arrays
3. Manual curl test for sensitivity endpoint with charge_delta_grains=0.3 returns 3 simulation results
</verification>

<success_criteria>
- SimResult and API responses include 4 new curve arrays (burn, energy, temperature, recoil) each with 200 data points
- /simulate/sensitivity endpoint returns center/upper/lower simulation results in single response
- All existing tests pass unchanged (backward compatibility)
- New tests verify curve data correctness and sensitivity endpoint behavior
</success_criteria>

<output>
After completion, create `.planning/phases/02-extended-simulation-charts/02-01-SUMMARY.md`
</output>
