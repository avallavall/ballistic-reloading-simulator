---
phase: 04-search-and-pagination
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/db/migrations/versions/006_search_and_pagination.py
  - backend/app/models/bullet.py
  - backend/app/models/cartridge.py
  - backend/app/schemas/bullet.py
  - backend/app/schemas/cartridge.py
  - backend/app/schemas/powder.py
  - backend/app/services/pagination.py
  - backend/app/services/search.py
  - backend/app/core/quality.py
autonomous: true
requirements:
  - SRC-01
  - SRC-02
  - SRC-03

must_haves:
  truths:
    - "Bullet and cartridge ORM models expose quality_score, data_source, and (bullets only) caliber_family columns"
    - "Paginated response schemas exist for powders, bullets, and cartridges with items/total/page/size fields"
    - "A reusable paginate() helper wraps any SQLAlchemy query with count + offset/limit"
    - "A reusable apply_fuzzy_search() helper applies pg_trgm % operator on name+manufacturer columns"
    - "Alembic migration 006 enables pg_trgm, creates GIN indexes, adds quality/caliber columns to bullets and cartridges"
  artifacts:
    - path: "backend/app/db/migrations/versions/006_search_and_pagination.py"
      provides: "pg_trgm extension, GIN indexes on name/manufacturer, quality_score/data_source/caliber_family columns"
      contains: "CREATE EXTENSION IF NOT EXISTS pg_trgm"
    - path: "backend/app/services/pagination.py"
      provides: "Reusable async paginate() helper"
      contains: "async def paginate"
    - path: "backend/app/services/search.py"
      provides: "Fuzzy search + caliber family derivation"
      contains: "def apply_fuzzy_search"
    - path: "backend/app/models/bullet.py"
      provides: "Bullet ORM with quality_score, data_source, caliber_family columns"
      contains: "quality_score"
    - path: "backend/app/models/cartridge.py"
      provides: "Cartridge ORM with quality_score, data_source columns"
      contains: "quality_score"
  key_links:
    - from: "backend/app/services/pagination.py"
      to: "sqlalchemy.ext.asyncio.AsyncSession"
      via: "async execute with func.count() + offset/limit"
      pattern: "func\\.count\\(\\)"
    - from: "backend/app/services/search.py"
      to: "pg_trgm operators"
      via: "SQLAlchemy op('%') and func.similarity()"
      pattern: "op\\(\"%\"\\)"
---

<objective>
Create the foundation for search and pagination: Alembic migration (pg_trgm extension, GIN indexes, new columns on bullets/cartridges), updated ORM models and schemas, and reusable service helpers for pagination and fuzzy search.

Purpose: All three endpoints (powders, bullets, cartridges) share the same pagination/search/filter patterns. Building reusable helpers first eliminates code duplication and ensures consistent behavior in Plan 02.

Output: Migration file, updated models/schemas, pagination + search service modules.
</objective>

<execution_context>
@C:/Users/vall-/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/vall-/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-search-and-pagination/04-RESEARCH.md

# Existing code patterns
@backend/app/db/migrations/versions/005_add_quality_and_web_thickness.py
@backend/app/models/bullet.py
@backend/app/models/cartridge.py
@backend/app/models/powder.py
@backend/app/schemas/powder.py
@backend/app/schemas/bullet.py
@backend/app/schemas/cartridge.py
@backend/app/core/quality.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Alembic migration, ORM models, and quality scorers for bullets/cartridges</name>
  <files>
    backend/app/db/migrations/versions/006_search_and_pagination.py
    backend/app/models/bullet.py
    backend/app/models/cartridge.py
    backend/app/core/quality.py
  </files>
  <action>
**1. Create Alembic migration `006_search_and_pagination.py`:**
- `revision = "006_search_pagination"`, `down_revision = "005_quality_web_thickness"`
- upgrade():
  - `CREATE EXTENSION IF NOT EXISTS pg_trgm`
  - Add columns to `bullets`: `data_source` (String(20), NOT NULL, server_default="manual"), `quality_score` (Integer, NOT NULL, server_default="0"), `caliber_family` (String(20), nullable=True)
  - Add columns to `cartridges`: `data_source` (String(20), NOT NULL, server_default="manual"), `quality_score` (Integer, NOT NULL, server_default="0"), `caliber_family` (String(20), nullable=True)
  - GIN indexes for pg_trgm fuzzy search: `ix_powders_name_trgm` on `powders(name gin_trgm_ops)`, `ix_powders_mfg_trgm` on `powders(manufacturer gin_trgm_ops)`, `ix_bullets_name_trgm` on `bullets(name gin_trgm_ops)`, `ix_bullets_mfg_trgm` on `bullets(manufacturer gin_trgm_ops)`, `ix_cartridges_name_trgm` on `cartridges(name gin_trgm_ops)`
  - B-tree indexes for filter queries: `ix_powders_quality` on `powders(quality_score)`, `ix_bullets_quality` on `bullets(quality_score)`, `ix_bullets_caliber` on `bullets(caliber_family)`, `ix_cartridges_quality` on `cartridges(quality_score)`
  - Backfill `caliber_family` for existing bullets using SQL UPDATEs: `.224` for 5.5-5.8mm, `.243` for 6.1-6.3mm, `.264` for 6.5-6.8mm, `.284` for 7.0-7.3mm, `.308` for 7.7-7.9mm, `.338` for 8.5-8.7mm. Same backfill for cartridges using `bore_diameter_mm`.
- downgrade(): Drop all indexes, then drop all added columns, then `DROP EXTENSION IF EXISTS pg_trgm`

**2. Update `backend/app/models/bullet.py`:**
- Add three new columns: `data_source = Column(String(20), nullable=False, default="manual")`, `quality_score = Column(Integer, nullable=False, default=0)`, `caliber_family = Column(String(20), nullable=True)`
- Import Integer from sqlalchemy

**3. Update `backend/app/models/cartridge.py`:**
- Add three new columns: `data_source = Column(String(20), nullable=False, default="manual")`, `quality_score = Column(Integer, nullable=False, default=0)`, `caliber_family = Column(String(20), nullable=True)`
- Import Integer from sqlalchemy

**4. Add bullet/cartridge quality scorers to `backend/app/core/quality.py`:**
- Add `BULLET_CRITICAL_FIELDS = ["weight_grains", "diameter_mm", "bc_g1", "sectional_density"]`
- Add `BULLET_BONUS_FIELDS = ["bc_g7", "length_mm"]`
- Add `CARTRIDGE_CRITICAL_FIELDS = ["saami_max_pressure_psi", "case_capacity_grains_h2o", "bore_diameter_mm", "groove_diameter_mm"]`
- Add `CARTRIDGE_BONUS_FIELDS = ["cip_max_pressure_mpa", "case_length_mm", "overall_length_mm"]`
- Add `compute_bullet_quality_score(bullet_dict, data_source)` returning QualityBreakdown -- same formula as powder (30% completeness + 70% source) with bullet fields
- Add `compute_cartridge_quality_score(cartridge_dict, data_source)` returning QualityBreakdown -- same formula with cartridge fields
- Keep existing `compute_quality_score` untouched for backward compatibility (rename in comments only as "powder quality scorer")
  </action>
  <verify>
Run `cd C:/Users/vall-/Desktop/projectes/simulador_balistica/backend && python -c "from app.models.bullet import Bullet; print([c.key for c in Bullet.__table__.columns])"` -- should include quality_score, data_source, caliber_family.
Run `cd C:/Users/vall-/Desktop/projectes/simulador_balistica/backend && python -c "from app.core.quality import compute_bullet_quality_score, compute_cartridge_quality_score; print('OK')"` -- should print OK.
  </verify>
  <done>Bullet and Cartridge ORM models have quality_score, data_source, caliber_family columns. Quality scorer functions exist for all three entity types. Migration 006 file exists with pg_trgm, GIN indexes, new columns, and caliber_family backfill.</done>
</task>

<task type="auto">
  <name>Task 2: Paginated response schemas and reusable pagination/search service helpers</name>
  <files>
    backend/app/services/__init__.py
    backend/app/services/pagination.py
    backend/app/services/search.py
    backend/app/schemas/powder.py
    backend/app/schemas/bullet.py
    backend/app/schemas/cartridge.py
  </files>
  <action>
**1. Create `backend/app/services/__init__.py`** -- empty file.

**2. Create `backend/app/services/pagination.py`:**
```python
from dataclasses import dataclass
from sqlalchemy import func, select
from sqlalchemy.ext.asyncio import AsyncSession

@dataclass
class PaginatedResult:
    items: list
    total: int
    page: int
    size: int

async def paginate(
    db: AsyncSession,
    query,
    page: int = 1,
    size: int = 50,
) -> PaginatedResult:
    """Wrap a SQLAlchemy query with count + offset/limit pagination."""
    count_q = select(func.count()).select_from(query.subquery())
    total = (await db.execute(count_q)).scalar() or 0
    offset = (page - 1) * size
    result = await db.execute(query.offset(offset).limit(size))
    items = list(result.scalars().all())
    return PaginatedResult(items=items, total=total, page=page, size=size)
```

**3. Create `backend/app/services/search.py`:**
- `CALIBER_FAMILIES` dict mapping family names to (min_diameter, max_diameter) tuples:
  `.224`: (5.5, 5.8), `.243`: (6.1, 6.3), `.264`: (6.5, 6.8), `.284`: (7.0, 7.3), `.308`: (7.7, 7.9), `.338`: (8.5, 8.7), `.375`: (9.5, 9.6), `.408`: (10.3, 10.4), `.416`: (10.5, 10.7), `.458`: (11.5, 11.7), `.510`: (12.9, 13.1)
- `derive_caliber_family(diameter_mm: float) -> str | None` -- iterate CALIBER_FAMILIES, return matching family or None
- `apply_fuzzy_search(query, model, search_term: str)` -- applies `or_(model.name.op("%")(search_term), model.manufacturer.op("%")(search_term))` WHERE clause, then orders by `func.similarity(model.name, search_term).desc()` then `model.quality_score.desc()` as tiebreaker. Returns the modified query.
- `CALIBER_FAMILY_LIST` constant: sorted list of all caliber family keys for API validation

**4. Add paginated response schemas:**
- In `backend/app/schemas/powder.py`, add at the end (after GrtImportResult):
  ```python
  class PaginatedPowderResponse(BaseModel):
      items: list[PowderResponse]
      total: int
      page: int
      size: int
  ```
- In `backend/app/schemas/bullet.py`, add `quality_score: int = 0`, `data_source: str = "manual"`, `caliber_family: str | None = None`, `quality_level` and `quality_tooltip` computed fields to BulletResponse (follow same pattern as PowderResponse but using `compute_bullet_quality_score`). Then add:
  ```python
  class PaginatedBulletResponse(BaseModel):
      items: list[BulletResponse]
      total: int
      page: int
      size: int
  ```
- In `backend/app/schemas/cartridge.py`, add `quality_score: int = 0`, `data_source: str = "manual"`, `caliber_family: str | None = None`, `quality_level` and `quality_tooltip` computed fields to CartridgeResponse (using `compute_cartridge_quality_score`). Then add:
  ```python
  class PaginatedCartridgeResponse(BaseModel):
      items: list[CartridgeResponse]
      total: int
      page: int
      size: int
  ```

For BulletResponse quality_tooltip, show: score/100, source label, filled/total fields, missing fields. Use BULLET_CRITICAL_FIELDS + BULLET_BONUS_FIELDS from quality module.
For CartridgeResponse quality_tooltip, same pattern with CARTRIDGE_CRITICAL_FIELDS + CARTRIDGE_BONUS_FIELDS.
  </action>
  <verify>
Run `cd C:/Users/vall-/Desktop/projectes/simulador_balistica/backend && python -c "from app.services.pagination import paginate, PaginatedResult; from app.services.search import apply_fuzzy_search, derive_caliber_family, CALIBER_FAMILIES; print('Services OK')"`.
Run `cd C:/Users/vall-/Desktop/projectes/simulador_balistica/backend && python -c "from app.schemas.powder import PaginatedPowderResponse; from app.schemas.bullet import PaginatedBulletResponse; from app.schemas.cartridge import PaginatedCartridgeResponse; print('Schemas OK')"`.
  </verify>
  <done>Reusable paginate() and apply_fuzzy_search() helpers exist. All three entities have PaginatedXxxResponse schemas. BulletResponse and CartridgeResponse include quality_score, data_source, caliber_family, quality_level, and quality_tooltip fields.</done>
</task>

</tasks>

<verification>
1. `python -c "from app.models.bullet import Bullet; print([c.key for c in Bullet.__table__.columns])"` includes quality_score, data_source, caliber_family
2. `python -c "from app.models.cartridge import Cartridge; print([c.key for c in Cartridge.__table__.columns])"` includes quality_score, data_source, caliber_family
3. `python -c "from app.services.pagination import paginate; from app.services.search import apply_fuzzy_search, derive_caliber_family; print('OK')"` prints OK
4. `python -c "from app.schemas.powder import PaginatedPowderResponse; from app.schemas.bullet import PaginatedBulletResponse; from app.schemas.cartridge import PaginatedCartridgeResponse; print('OK')"` prints OK
5. Migration file `006_search_and_pagination.py` exists with pg_trgm, GIN indexes, new columns
6. `python -m pytest tests/ -v` -- existing tests still pass (no regressions)
</verification>

<success_criteria>
- Alembic migration 006 creates pg_trgm extension, GIN indexes on name/manufacturer for all 3 entities, quality_score/data_source/caliber_family columns on bullets and cartridges
- ORM models for Bullet and Cartridge expose the new columns
- Paginated response schemas exist for all 3 entities with items/total/page/size
- Reusable paginate() and apply_fuzzy_search() helpers are importable and tested via smoke import
- BulletResponse and CartridgeResponse include quality_level and quality_tooltip computed fields
- All existing tests pass unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/04-search-and-pagination/04-01-SUMMARY.md`
</output>
