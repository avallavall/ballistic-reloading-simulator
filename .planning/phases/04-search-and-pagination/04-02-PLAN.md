---
phase: 04-search-and-pagination
plan: 02
type: execute
wave: 2
depends_on:
  - "04-01"
files_modified:
  - backend/app/api/powders.py
  - backend/app/api/bullets.py
  - backend/app/api/cartridges.py
  - frontend/src/lib/api.ts
  - frontend/src/lib/types.ts
  - frontend/src/hooks/usePowders.ts
  - frontend/src/hooks/useBullets.ts
  - frontend/src/hooks/useCartridges.ts
  - backend/tests/test_search_pagination.py
autonomous: true
requirements:
  - SRC-01
  - SRC-02
  - SRC-03

must_haves:
  truths:
    - "GET /api/v1/powders returns paginated envelope {items, total, page, size} with default page=1, size=50"
    - "GET /api/v1/bullets returns paginated envelope {items, total, page, size} with default page=1, size=50"
    - "GET /api/v1/cartridges returns paginated envelope {items, total, page, size} with default page=1, size=50"
    - "GET /api/v1/powders?q=hodgon applies pg_trgm fuzzy search on name+manufacturer and returns results ranked by similarity"
    - "GET /api/v1/powders?manufacturer=Hodgdon filters by exact manufacturer match"
    - "GET /api/v1/bullets?caliber_family=.308 filters bullets by caliber family"
    - "GET /api/v1/powders?quality_level=success filters by quality badge tier (score >= 70)"
    - "GET /api/v1/powders/manufacturers returns distinct manufacturer names dynamically"
    - "GET /api/v1/bullets/manufacturers returns distinct manufacturer names dynamically"
    - "GET /api/v1/bullets/caliber-families returns distinct caliber family values dynamically"
    - "Frontend hooks unwrap .items from paginated response so existing pages still render"
    - "All existing tests pass; new pagination/filter tests pass against SQLite"
  artifacts:
    - path: "backend/app/api/powders.py"
      provides: "Paginated, searchable, filterable list_powders endpoint + /manufacturers sub-route"
      contains: "PaginatedPowderResponse"
    - path: "backend/app/api/bullets.py"
      provides: "Paginated, searchable, filterable list_bullets endpoint + /manufacturers and /caliber-families sub-routes"
      contains: "PaginatedBulletResponse"
    - path: "backend/app/api/cartridges.py"
      provides: "Paginated, searchable, filterable list_cartridges endpoint + /manufacturers and /caliber-families sub-routes"
      contains: "PaginatedCartridgeResponse"
    - path: "frontend/src/lib/api.ts"
      provides: "Updated API client functions returning PaginatedResponse<T>"
      contains: "PaginatedResponse"
    - path: "frontend/src/hooks/usePowders.ts"
      provides: "usePowders unwraps .items for backward compat"
      contains: "data.items"
    - path: "backend/tests/test_search_pagination.py"
      provides: "Tests for pagination, filtering, sort, and backward compat"
      contains: "test_powders_pagination"
  key_links:
    - from: "backend/app/api/powders.py"
      to: "backend/app/services/pagination.py"
      via: "paginate() call"
      pattern: "from app\\.services\\.pagination import paginate"
    - from: "backend/app/api/powders.py"
      to: "backend/app/services/search.py"
      via: "apply_fuzzy_search() call"
      pattern: "from app\\.services\\.search import apply_fuzzy_search"
    - from: "frontend/src/hooks/usePowders.ts"
      to: "frontend/src/lib/api.ts"
      via: "getPowders() returns PaginatedResponse, hook unwraps .items"
      pattern: "select.*data\\.items"
---

<objective>
Modify all three component list endpoints to support pagination, fuzzy search, and multi-field filtering using the helpers from Plan 01. Update frontend API client and hooks for backward compatibility. Add comprehensive tests.

Purpose: Delivers the user-facing behavior for SRC-01 (pagination), SRC-02 (fuzzy search), and SRC-03 (filtering). After this plan, the API contract is complete and ready for Phase 6's frontend UI.

Output: Modified endpoints, updated frontend client/hooks, new test file.
</objective>

<execution_context>
@C:/Users/vall-/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/vall-/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-search-and-pagination/04-RESEARCH.md
@.planning/phases/04-search-and-pagination/04-01-SUMMARY.md

# Current endpoint files (to be modified)
@backend/app/api/powders.py
@backend/app/api/bullets.py
@backend/app/api/cartridges.py

# Frontend files (to be modified)
@frontend/src/lib/api.ts
@frontend/src/lib/types.ts
@frontend/src/hooks/usePowders.ts
@frontend/src/hooks/useBullets.ts
@frontend/src/hooks/useCartridges.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Modify all three list endpoints with pagination, search, filtering, and dynamic manufacturer/caliber routes</name>
  <files>
    backend/app/api/powders.py
    backend/app/api/bullets.py
    backend/app/api/cartridges.py
  </files>
  <action>
**Per user decisions (LOCKED):**
- Default page=1, size=50, max size=200 (reject >200)
- Default sort: quality_score desc
- Sort configurable: ?sort=name|manufacturer|quality_score&order=asc|desc
- Fuzzy search on name+manufacturer only, min query length 3 chars
- Powders: filter by manufacturer + burn_rate_min/burn_rate_max (NO caliber filter)
- Bullets/cartridges: filter by caliber_family
- Quality filter: dual mode -- quality_level (success/warning/danger badge tier) AND min_quality (integer threshold)
- Manufacturer list: dynamic SELECT DISTINCT, no hardcoded list

**Per Claude's discretion (RESEARCH recommendations):**
- Search + filter + pagination compose freely (AND logic)
- When q= is present, sort by similarity relevance (ignore user sort param). When q= is absent, use sort/order params
- Modify existing GET endpoints in-place with optional query params (no separate /search routes)
- Return-all-ranked approach for pg_trgm (default 0.3 threshold, no custom cutoff)

**Modify `backend/app/api/powders.py`:**
1. Add imports: `from fastapi import Query`, `from app.services.pagination import paginate`, `from app.services.search import apply_fuzzy_search`, `from app.schemas.powder import PaginatedPowderResponse`
2. Change `list_powders` signature to accept query params:
   - `q: str | None = Query(None, min_length=3, description="Fuzzy search on name/manufacturer")`
   - `manufacturer: str | None = Query(None)`
   - `burn_rate_min: float | None = Query(None, ge=0)`
   - `burn_rate_max: float | None = Query(None, le=500)`
   - `quality_level: str | None = Query(None, description="Badge tier: success/warning/danger")`
   - `min_quality: int | None = Query(None, ge=0, le=100)`
   - `sort: str = Query("quality_score")` -- allowed: name, manufacturer, quality_score
   - `order: str = Query("desc")` -- allowed: asc, desc
   - `page: int = Query(1, ge=1)`
   - `size: int = Query(50, ge=1, le=200)`
3. Change response_model to `PaginatedPowderResponse`
4. Build query: `query = select(Powder)`
   - If q: `query = apply_fuzzy_search(query, Powder, q)`
   - If manufacturer: `.where(Powder.manufacturer == manufacturer)`
   - If burn_rate_min: `.where(Powder.burn_rate_relative >= burn_rate_min)`
   - If burn_rate_max: `.where(Powder.burn_rate_relative <= burn_rate_max)`
   - If quality_level: map to score range (success: 70-100, warning: 40-69, danger: 0-39) and add WHERE
   - If min_quality: `.where(Powder.quality_score >= min_quality)`
   - If NOT q: apply sort/order (validate sort column exists on model, fallback to quality_score)
5. `return await paginate(db, query, page, size)`
6. Add new sub-route `GET /manufacturers` returning `list[str]` via `select(Powder.manufacturer).distinct().where(Powder.manufacturer.isnot(None)).order_by(Powder.manufacturer)`
   - IMPORTANT: Place this route BEFORE the `/{powder_id}` route to avoid FastAPI treating "manufacturers" as a UUID

**Modify `backend/app/api/bullets.py`:**
1. Same pagination/search pattern as powders
2. Filter params: `manufacturer`, `caliber_family`, `quality_level`, `min_quality` (NO burn_rate filter)
3. response_model = `PaginatedBulletResponse`
4. Import `from app.services.search import apply_fuzzy_search`, `from app.services.pagination import paginate`
5. Add quality_score auto-compute in create_bullet and update_bullet (same pattern as powders: `from app.core.quality import compute_bullet_quality_score`, compute on create, recompute on update)
6. Add caliber_family auto-derive in create_bullet: `from app.services.search import derive_caliber_family`, set `bullet.caliber_family = derive_caliber_family(bullet.diameter_mm)`
7. Add sub-routes: `GET /manufacturers` (DISTINCT manufacturer), `GET /caliber-families` (DISTINCT caliber_family WHERE NOT NULL)
   - IMPORTANT: Place these routes BEFORE the `/{bullet_id}` route

**Modify `backend/app/api/cartridges.py`:**
1. Same pagination/search pattern
2. Filter params: `manufacturer` (cartridges don't have manufacturer field -- cartridges have only `name`. Use `caliber_family` filter instead), `caliber_family`, `quality_level`, `min_quality`
   - NOTE: Cartridge model does NOT have a `manufacturer` column. So no manufacturer filter for cartridges. The search `q` param only matches against `name`. Adjust `apply_fuzzy_search` call: since cartridges lack manufacturer, apply search only on `model.name.op("%")(search_term)` -- add an optional `search_fields` parameter to `apply_fuzzy_search` or handle the single-field case by checking `hasattr(model, "manufacturer")`.
3. response_model = `PaginatedCartridgeResponse`
4. Add quality_score auto-compute in create_cartridge and update_cartridge using `compute_cartridge_quality_score`
5. Add caliber_family auto-derive: `derive_caliber_family(cartridge.bore_diameter_mm)`
6. Add sub-route: `GET /caliber-families` (DISTINCT caliber_family WHERE NOT NULL)
   - IMPORTANT: Place before `/{cartridge_id}` route

**Update `backend/app/services/search.py` (if needed):**
If the apply_fuzzy_search function needs to handle models without a `manufacturer` column (cartridges), add a `fields` parameter defaulting to `["name", "manufacturer"]`. When a field doesn't exist on the model, skip it. This avoids import-time model coupling while handling the cartridge case cleanly.
  </action>
  <verify>
Run `cd C:/Users/vall-/Desktop/projectes/simulador_balistica/backend && python -c "from app.api.powders import router; routes = [r.path for r in router.routes]; print(routes)"` -- should include `/manufacturers`.
Run `cd C:/Users/vall-/Desktop/projectes/simulador_balistica/backend && python -c "from app.api.bullets import router; routes = [r.path for r in router.routes]; print(routes)"` -- should include `/manufacturers` and `/caliber-families`.
  </verify>
  <done>All three list endpoints accept page/size/q/sort/order/quality_level/min_quality params and return PaginatedXxxResponse. Powders additionally filter by manufacturer+burn_rate_range. Bullets filter by manufacturer+caliber_family. Cartridges filter by caliber_family. Dynamic manufacturer and caliber-family sub-routes exist. Quality auto-compute on bullet/cartridge create and update.</done>
</task>

<task type="auto">
  <name>Task 2: Frontend backward compatibility and comprehensive tests</name>
  <files>
    frontend/src/lib/api.ts
    frontend/src/lib/types.ts
    frontend/src/hooks/usePowders.ts
    frontend/src/hooks/useBullets.ts
    frontend/src/hooks/useCartridges.ts
    backend/tests/test_search_pagination.py
  </files>
  <action>
**Frontend changes (minimal -- Phase 6 builds the full search/pagination UI):**

1. **`frontend/src/lib/api.ts`:**
   - Update `getPowders()`: change return type from `Promise<Powder[]>` to `Promise<PaginatedResponse<Powder>>`. Change request type from `Powder[]` to `PaginatedResponse<Powder>`.
   - Same for `getBullets()`: return `Promise<PaginatedResponse<Bullet>>`.
   - Same for `getCartridges()`: return `Promise<PaginatedResponse<Cartridge>>`.
   - Import `PaginatedResponse` from types.ts (already defined there at line 296).

2. **`frontend/src/lib/types.ts`:**
   - Add `quality_score?: number`, `data_source?: string`, `caliber_family?: string | null`, `quality_level?: string`, `quality_tooltip?: string` fields to the `Bullet` interface.
   - Add `quality_score?: number`, `data_source?: string`, `caliber_family?: string | null`, `quality_level?: string`, `quality_tooltip?: string` fields to the `Cartridge` interface.
   - These are optional (?) to not break existing code that constructs these types without quality fields.

3. **`frontend/src/hooks/usePowders.ts`:**
   - Update `usePowders()` to add `select: (data) => data.items` to the useQuery options. This unwraps the paginated envelope so all existing components that consume `usePowders().data` as an array continue working without changes.

4. **`frontend/src/hooks/useBullets.ts`:**
   - Same pattern: add `select: (data) => data.items`.

5. **`frontend/src/hooks/useCartridges.ts`:**
   - Same pattern: add `select: (data) => data.items`.

**Backend tests (`backend/tests/test_search_pagination.py`):**

Create a new test file testing pagination and filtering against the aiosqlite backend. pg_trgm search tests must be skipped (SQLite doesn't support pg_trgm).

Test setup: Use the same pattern as `test_api_integration.py` -- patch database before imports, create AsyncClient with ASGITransport.

Tests to write (at least 10):

**Pagination tests (work with SQLite):**
1. `test_powders_pagination_default`: GET /powders with no params returns envelope with items/total/page/size
2. `test_powders_pagination_page_size`: GET /powders?page=1&size=2 returns at most 2 items, correct total
3. `test_powders_pagination_second_page`: GET /powders?page=2&size=1 returns correct item
4. `test_powders_size_cap_200`: GET /powders?size=300 returns 422 validation error
5. `test_bullets_pagination_default`: GET /bullets returns paginated envelope
6. `test_cartridges_pagination_default`: GET /cartridges returns paginated envelope

**Filter tests (work with SQLite):**
7. `test_powders_filter_manufacturer`: Create 2 powders with different manufacturers, filter by one, get only matching
8. `test_powders_filter_quality_level`: Create powder with quality_score 80, filter quality_level=success, it appears; filter quality_level=danger, it doesn't
9. `test_powders_filter_min_quality`: Create powders with different scores, filter min_quality=50, only high-score appears
10. `test_bullets_filter_caliber_family`: Create bullets with different diameters, filter by caliber_family=.308

**Sort tests:**
11. `test_powders_sort_by_name_asc`: GET /powders?sort=name&order=asc returns alphabetical order
12. `test_powders_default_sort_quality_desc`: Default sort is quality_score descending

**Dynamic list tests:**
13. `test_powders_manufacturers_list`: GET /powders/manufacturers returns distinct manufacturers
14. `test_bullets_caliber_families_list`: GET /bullets/caliber-families returns distinct families

**Search test (marked skip for SQLite):**
15. `test_fuzzy_search_requires_postgres`: Mark with `@pytest.mark.skipif` or a comment explaining pg_trgm not available in SQLite. Include a placeholder test that documents the expected behavior.

**Backward compat tests:**
16. `test_existing_crud_still_works`: POST/GET/PUT/DELETE on powders still works with the new pagination wrapper

Note: Use `@pytest.mark.asyncio` for all tests. Seed test data in fixtures. Validate response JSON structure explicitly.
  </action>
  <verify>
Run `cd C:/Users/vall-/Desktop/projectes/simulador_balistica/backend && python -m pytest tests/test_search_pagination.py -v` -- all non-skipped tests pass.
Run `cd C:/Users/vall-/Desktop/projectes/simulador_balistica/backend && python -m pytest tests/ -v` -- all existing + new tests pass.
Run `cd C:/Users/vall-/Desktop/projectes/simulador_balistica/frontend && npx tsc --noEmit` -- TypeScript compiles with no errors.
  </verify>
  <done>Frontend hooks unwrap .items for backward compatibility. API client returns PaginatedResponse. Bullet/Cartridge TS types include quality fields. 15+ new tests cover pagination, filtering, sorting, dynamic lists, and backward compat. All tests (existing + new) pass. TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
1. `curl http://localhost:8000/api/v1/powders` returns `{"items": [...], "total": N, "page": 1, "size": 50}`
2. `curl http://localhost:8000/api/v1/powders?page=1&size=5` returns at most 5 items with correct total
3. `curl http://localhost:8000/api/v1/powders?q=hodgon` returns Hodgdon powders ranked by similarity (requires live PostgreSQL)
4. `curl http://localhost:8000/api/v1/powders?manufacturer=Hodgdon` returns only Hodgdon powders
5. `curl http://localhost:8000/api/v1/powders?quality_level=success` returns powders with score >= 70
6. `curl http://localhost:8000/api/v1/powders/manufacturers` returns distinct manufacturer list
7. `curl http://localhost:8000/api/v1/bullets/caliber-families` returns distinct caliber families
8. `python -m pytest tests/ -v` -- all tests pass (200+ total with new tests)
9. `npx tsc --noEmit` -- frontend compiles cleanly
10. Frontend pages (/powders, /bullets, /cartridges) still render data correctly (hooks unwrap .items)
</verification>

<success_criteria>
- All three list endpoints return paginated envelope {items, total, page, size} with configurable page/size
- Search via q= applies pg_trgm fuzzy matching on name+manufacturer (requires PostgreSQL)
- Filters compose via AND logic: manufacturer, burn_rate_range (powders), caliber_family (bullets/cartridges), quality_level, min_quality
- Sort defaults to quality_score desc; configurable via sort/order params
- Dynamic /manufacturers and /caliber-families sub-routes return DISTINCT values
- Frontend hooks unwrap .items for backward compatibility
- 15+ new tests pass, all existing tests pass, TypeScript compiles
</success_criteria>

<output>
After completion, create `.planning/phases/04-search-and-pagination/04-02-SUMMARY.md`
</output>
